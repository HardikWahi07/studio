/**
 * @fileoverview Firestore Security Rules for TripMind application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-related data (profiles, trips, expenses, itinerary items),
 * while allowing public read access to local business, supporter, and app statistics data.  The rules are designed to prevent
 * unauthorized data access and modification, aligning with the principles of Authorization Independence and
 * Database-Based Access Control (DBAC).
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data.
 * - /users/{userId}/trips/{tripId}: Stores trip data associated with a user.
 * - /users/{userId}/trips/{tripId}/expenses/{expenseId}: Stores expense data associated with a trip and user.
 * - /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}: Stores itinerary items associated with a trip.
 * - /local_businesses/{localBusinessId}: Stores data for local businesses.
 * - /app-stats/{statId}: Stores global application statistics.
 * - /supporters/{supporterId}: Stores profiles of local supporters.
 * - /bookings/{bookingId}: Stores booking data.
 *
 * Key Security Decisions:
 * - User data is strictly controlled by the user's ID in the path.
 * - Local business, supporter, and app statistics data are publicly readable (get, list).
 * - User can only list their own bookings.
 * - For now, data shape validation is not enforced beyond requiring an ownerId for certain write operations.
 *   This is to facilitate rapid prototyping and schema evolution.
 *
 * Denormalization for Authorization:
 * - Ownership is determined directly from the document path (/users/{userId}/...). This avoids the need for costly `get()` calls
 *   to determine ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data. Only the user can read/write their own data.
     * @path /users/{userId}
     * @allow (create) - Authenticated user with UID 'user123' can create their own profile if request.auth.uid == 'user123'.
     * @allow (get, list, update, delete) - Authenticated user with UID 'user123' can read/write their own profile if request.auth.uid == 'user123'.
     * @deny (create) - Authenticated user with UID 'user456' cannot create a profile for user 'user123' if request.auth.uid != 'user123'.
     * @deny (get, list, update, delete) - Authenticated user with UID 'user456' cannot read/write profile 'user123' if request.auth.uid != 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages trip data associated with a user. Only the user can manage their trips.
     * @path /users/{userId}/trips/{tripId}
     * @allow (create) - Authenticated user with UID 'user123' can create a trip under their profile (users/user123/trips/trip001) if request.auth.uid == 'user123'.
     * @allow (get, list, update, delete) - Authenticated user with UID 'user123' can read/write a trip under their profile (users/user123/trips/trip001) if request.auth.uid == 'user123'.
     * @deny (create) - Authenticated user with UID 'user456' cannot create a trip under user 'user123''s profile (users/user123/trips/trip001) if request.auth.uid != 'user123'.
     * @deny (get, list, update, delete) - Authenticated user with UID 'user456' cannot read/write a trip under user 'user123''s profile (users/user123/trips/trip001) if request.auth.uid != 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/trips/{tripId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages expense data associated with a trip and user. Only the user can manage their expenses.
     * @path /users/{userId}/trips/{tripId}/expenses/{expenseId}
     * @allow (create) - Authenticated user with UID 'user123' can create an expense under their trip (users/user123/trips/trip001/expenses/expense001) if request.auth.uid == 'user123'.
     * @allow (get, list, update, delete) - Authenticated user with UID 'user123' can read/write an expense under their trip (users/user123/trips/trip001/expenses/expense001) if request.auth.uid == 'user123'.
     * @deny (create) - Authenticated user with UID 'user456' cannot create an expense under user 'user123''s trip (users/user123/trips/trip001/expenses/expense001) if request.auth.uid != 'user123'.
     * @deny (get, list, update, delete) - Authenticated user with UID 'user456' cannot read/write an expense under user 'user123''s trip (users/user123/trips/trip001/expenses/expense001) if request.auth.uid != 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/trips/{tripId}/expenses/{expenseId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages itinerary items associated with a trip. Only the user can manage their itinerary items.
     * @path /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}
     * @allow (create) - Authenticated user with UID 'user123' can create an itinerary item under their trip (users/user123/trips/trip001/itinerary_items/item001) if request.auth.uid == 'user123'.
     * @allow (get, list, update, delete) - Authenticated user with UID 'user123' can read/write an itinerary item under their trip (users/user123/trips/trip001/itinerary_items/item001) if request.auth.uid == 'user123'.
     * @deny (create) - Authenticated user with UID 'user456' cannot create an itinerary item under user 'user123''s trip (users/user123/trips/trip001/itinerary_items/item001) if request.auth.uid != 'user123'.
     * @deny (get, list, update, delete) - Authenticated user with UID 'user456' cannot read/write an itinerary item under user 'user123''s trip (users/user123/trips/trip001/itinerary_items/item001) if request.auth.uid != 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Stores data for local businesses. Publicly readable.
     * @path /local_businesses/{localBusinessId}
     * @allow (get, list) - Any user can read local business data.
     * @deny (create, update, delete) - No user can create, update, or delete local business data without additional authorization.
     * @principle Public read access with restricted writes.
     */
    match /local_businesses/{localBusinessId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores global application statistics. Publicly readable.
     * @path /app-stats/{statId}
     * @allow (get, list) - Any user can read app statistics.
     * @deny (create, update, delete) - No user can create, update, or delete app statistics without additional authorization.
     * @principle Public read access with restricted writes.
     */
    match /app-stats/{statId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores profiles of local supporters. Publicly readable.
     * @path /supporters/{supporterId}
     * @allow (get, list) - Any user can read local supporter profiles.
     * @deny (create, update, delete) - No user can create, update, or delete local supporter profiles without additional authorization.
     * @principle Public read access with restricted writes.
     */
    match /supporters/{supporterId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores confirmed bookings. Users can only list bookings where their userId matches the authenticated user's ID.
     *              Individual reads are allowed by either the user or the supporter involved in the booking.
     * @path /bookings/{bookingId}
     * @allow (list) - Authenticated user 'user123' can list bookings where booking.userId == 'user123'.
     * @allow (get) - Authenticated user 'user123' can read a booking where booking.userId == 'user123' OR booking.supporterId == 'user123'.
     * @allow (create) - Authenticated user 'user123' can create a booking where request.resource.data.userId == 'user123'.
     * @deny (list) - Authenticated user 'user123' cannot list all bookings in the database.
     * @deny (get) - Authenticated user 'user456' cannot read booking for 'user123' if user456 is not the user or supporter.
     * @deny (create, update, delete) - No user can update or delete a booking, as this should be handled by the system.
     * @principle Secure booking management with user-specific queries.
     */
    match /bookings/{bookingId} {
      allow get: if request.auth.uid != null && (resource.data.userId == request.auth.uid || resource.data.supporterId == request.auth.uid);
      allow list: if request.auth.uid != null && request.query.where("userId", "==", request.auth.uid).size() > 0;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }
  }
}