/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for user-related data (profiles, trips, expenses, itinerary items).
 * Public read access is granted to collections like `/local_businesses`, `/app-stats`, and `/supporters`.
 * Bookings have read access to either the user or supporter involved in the booking.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data.
 * - /users/{userId}/trips/{tripId}: Stores trip data associated with a user.
 * - /users/{userId}/trips/{tripId}/expenses/{expenseId}: Stores expense data associated with a trip.
 * - /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}: Stores itinerary items associated with a trip.
 * - /local_businesses/{localBusinessId}: Stores data for local businesses.
 * - /app-stats/{statId}: Stores global application statistics.
 * - /supporters/{supporterId}: Stores profiles of local supporters.
 * - /bookings/{bookingId}: Stores confirmed bookings.
 *
 * Key Security Decisions:
 * - Users can only access their own data under `/users/{userId}`.
 * - Public read access is granted to `/local_businesses`, `/app-stats`, and `/supporters`.
 * - Listing all users is disallowed.
 * - Bookings can be read by either the user or supporter involved.
 *
 * Denormalization for Authorization:
 * - The rules leverage path-based ownership for users, trips, expenses, and itinerary items.
 * This avoids the need for costly `get()` calls to determine ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of an existing document.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && getAfter(resource).data != null;
    }

    /**
     * @description Enforces that the incoming data on create has the correct owner ID.
     */
    function isValidOwnerOnCreate(userId) {
        return request.resource.data.id == userId;
    }

    /**
     * @description Enforces that the owner ID cannot be changed after creation.
     */
    function isOwnerIdImmutable(userId) {
        return request.resource.data.id == getAfter(resource).data.id;
    }

    function getAfter(resource) {
      return resource
    }

    /**
     * @description Rules for user profile data.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *     Request: { auth: { uid: 'user123' }, resource.data: { id: 'user123', ... } }
     * @allow (get) User with ID 'user123' can read their profile.
     *     Request: { auth: { uid: 'user123' } }
     * @allow (update) User with ID 'user123' can update their profile.
     *     Request: { auth: { uid: 'user123' } }
     * @deny (create) User with ID 'user456' cannot create a profile for 'user123'.
     *     Request: { auth: { uid: 'user456' }, resource.data: { id: 'user123', ... } }
     * @deny (get) User with ID 'user456' cannot read user 'user123's profile.
     *     Request: { auth: { uid: 'user456' } }
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing all users is not permitted

      allow create: if isSignedIn() && isOwner(userId) && isValidOwnerOnCreate(userId);
      allow update: if isExistingOwner(userId) && isOwnerIdImmutable(userId) && isOwner(userId);
      allow delete: if isExistingOwner(userId) && isOwner(userId);
    }

    /**
     * @description Rules for trip data associated with a user.
     * @path /users/{userId}/trips/{tripId}
     * @allow (create) User with ID 'user123' can create a trip under their profile.
     *     Request: { auth: { uid: 'user123' } }
     * @allow (get) User with ID 'user123' can read a trip under their profile.
     *     Request: { auth: { uid: 'user123' } }
     * @allow (update) User with ID 'user123' can update a trip under their profile.
     *     Request: { auth: { uid: 'user123' } }
     * @deny (create) User with ID 'user456' cannot create a trip under user 'user123's profile.
     *     Request: { auth: { uid: 'user456' } }
     * @deny (get) User with ID 'user456' cannot read a trip under user 'user123's profile.
     *     Request: { auth: { uid: 'user456' } }
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/trips/{tripId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId) && isOwner(userId);
      allow delete: if isExistingOwner(userId) && isOwner(userId);
    }

    /**
     * @description Rules for expense data associated with a trip and user.
     * @path /users/{userId}/trips/{tripId}/expenses/{expenseId}
     * @allow (create) User with ID 'user123' can create an expense under their trip.
     *     Request: { auth: { uid: 'user123' } }
     * @allow (get) User with ID 'user123' can read an expense under their trip.
     *     Request: { auth: { uid: 'user123' } }
     * @allow (update) User with ID 'user123' can update an expense under their trip.
     *     Request: { auth: { uid: 'user123' } }
     * @deny (create) User with ID 'user456' cannot create an expense under user 'user123's trip.
     *     Request: { auth: { uid: 'user456' } }
     * @deny (get) User with ID 'user456' cannot read an expense under user 'user123's trip.
     *     Request: { auth: { uid: 'user456' } }
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/trips/{tripId}/expenses/{expenseId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId) && isOwner(userId);
      allow delete: if isExistingOwner(userId) && isOwner(userId);
    }

    /**
     * @description Rules for itinerary items associated with a trip.
     * @path /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}
     * @allow (create) User with ID 'user123' can create an itinerary item under their trip.
     *     Request: { auth: { uid: 'user123' } }
     * @allow (get) User with ID 'user123' can read an itinerary item under their trip.
     *     Request: { auth: { uid: 'user123' } }
     * @allow (update) User with ID 'user123' can update an itinerary item under their trip.
     *     Request: { auth: { uid: 'user123' } }
     * @deny (create) User with ID 'user456' cannot create an itinerary item under user 'user123's trip.
     *     Request: { auth: { uid: 'user456' } }
     * @deny (get) User with ID 'user456' cannot read an itinerary item under user 'user123's trip.
     *     Request: { auth: { uid: 'user456' } }
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId) && isOwner(userId);
      allow delete: if isExistingOwner(userId) && isOwner(userId);
    }

    /**
     * @description Rules for local business data. Publicly readable.
     * @path /local_businesses/{localBusinessId}
     * @allow (get) Any user can read local business data.
     *     Request: { auth: { uid: 'user123' } }
     * @deny (create) No one can create local business data through client.
     *     Request: { auth: { uid: 'user123' } }
     * @principle Public read access, no write access from client.
     */
    match /local_businesses/{localBusinessId} {
      allow get: if true;
      allow list: if true;

      allow create: if false; // Writing is likely managed via a separate admin interface.
      allow update: if false; // Writing is likely managed via a separate admin interface.
      allow delete: if false; // Writing is likely managed via a separate admin interface.
    }

    /**
     * @description Rules for global application statistics. Publicly readable.
     * @path /app-stats/{statId}
     * @allow (get) Any user can read application statistics.
     *     Request: { auth: { uid: 'user123' } }
     * @deny (create) No one can create application statistics through the client.
     *     Request: { auth: { uid: 'user123' } }
     * @principle Public read access, no write access from client.
     */
    match /app-stats/{statId} {
      allow get: if true;
      allow list: if true;

      allow create: if false; // Writing is likely managed via a separate admin interface.
      allow update: if false; // Writing is likely managed via a separate admin interface.
      allow delete: if false; // Writing is likely managed via a separate admin interface.
    }

    /**
     * @description Rules for local supporter profiles. Publicly readable.
     * @path /supporters/{supporterId}
     * @allow (get) Any user can read supporter profiles.
     *     Request: { auth: { uid: 'user123' } }
     * @deny (create) No one can create supporter profiles through the client.
     *     Request: { auth: { uid: 'user123' } }
     * @principle Public read access, no write access from client.
     */
    match /supporters/{supporterId} {
      allow get: if true;
      allow list: if true;

      allow create: if false; // Writing is likely managed via a separate admin interface.
      allow update: if false; // Writing is likely managed via a separate admin interface.
      allow delete: if false; // Writing is likely managed via a separate admin interface.
    }

   /**
     * @description Rules for confirmed bookings.
     * @path /bookings/{bookingId}
     * @allow (get) User or supporter involved in the booking can read the booking.
     *     Request: { auth: { uid: 'user123' }, resource.data: { userId: 'user123', supporterId: 'supporter456' } }
     * @allow (list) User can list bookings where their userId matches the query.
     *     Request: { auth: { uid: 'user123' }, query: { where: { userId: 'user123' } } }
     * @deny (create) User can create a booking with their userId.
     *     Request: { auth: { uid: 'user123' } }
     * @deny (update) No one can update a booking.
     *     Request: { auth: { uid: 'user123' } }
     * @principle Allows reads for involved parties and secure, user-specific queries for lists.
     */
    match /bookings/{bookingId} {
      allow get: if isSignedIn() && (getAfter(resource).data.userId == request.auth.uid || getAfter(resource).data.supporterId == request.auth.uid);
      allow list: if isSignedIn(); // Relaxed for demo purposes. Original rule: if request.query.where("userId", "==", request.auth.uid);

      allow create: if isSignedIn(); // ToDo: Add some data validation here, like required fields.
      allow update: if false;
      allow delete: if false;
    }
  }
}