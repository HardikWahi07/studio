/**
 * @fileoverview Firestore Security Rules for TripMind application.
 *
 * Core Philosophy: This ruleset enforces a strict user-ownership model for user-related data (profiles, trips, expenses, itinerary items),
 * while allowing public read access to local business and supporter data. Bookings are accessible to the involved user or supporter.
 *
 * Data Structure:
 * - All user-specific data is nested under `/users/{userId}`.
 * - Public data (local businesses, app stats, supporters) resides in top-level collections.
 * - Bookings are stored in a top-level `/bookings` collection with access controlled by userId and supporterId.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Public read collections are explicitly marked.
 * - The default security posture for ambiguous relationships is strict owner-only access.
 * - Relational integrity is enforced on `create` and `update` to prevent orphaned or misdirected data.
 *
 * Denormalization for Authorization:
 * - The `bookings` collection uses `userId` and `supporterId` fields directly on each document.
 *   This allows security rules to quickly determine access without additional `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the document based on the provided userId.
     * @param {string} userId The user ID to compare against the authenticated user's UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the existing owner of the document.
     *              This function ensures that the document exists and that the user is the owner.
     * @param {string} userId The user ID to compare against the authenticated user's UID.
     * @return {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Security rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (get, create, update, delete) User with ID 'user123' can read, create, update, and delete their own profile.
     *          Example: Request by user 'user123' to create a document at /users/user123.
     * @deny (get, create, update, delete) User with ID 'user456' cannot read, create, update, or delete the profile of user 'user123'.
     *          Example: Request by user 'user456' to read a document at /users/user123.
     * @deny list: Listing all users is not allowed.
     *          Example: Request to list all documents in /users.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/trips/{tripId} collection.
     * @path /users/{userId}/trips/{tripId}
     * @allow (get, list, create, update, delete) User with ID 'user123' can manage their own trips.
     *          Example: Request by user 'user123' to create a trip under /users/user123/trips/trip001.
     * @deny (get, list, create, update, delete) User with ID 'user456' cannot manage trips of user 'user123'.
     *          Example: Request by user 'user456' to read a trip under /users/user123/trips/trip001.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/trips/{tripId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/trips/{tripId}/expenses/{expenseId} collection.
     * @path /users/{userId}/trips/{tripId}/expenses/{expenseId}
     * @allow (get, list, create, update, delete) User with ID 'user123' can manage expenses for their own trips.
     *          Example: Request by user 'user123' to create an expense under /users/user123/trips/trip001/expenses/expense001.
     * @deny (get, list, create, update, delete) User with ID 'user456' cannot manage expenses of user 'user123'.
     *          Example: Request by user 'user456' to read an expense under /users/user123/trips/trip001/expenses/expense001.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/trips/{tripId}/expenses/{expenseId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId} collection.
     * @path /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}
     * @allow (get, list, create, update, delete) User with ID 'user123' can manage itinerary items for their own trips.
     *          Example: Request by user 'user123' to create an itinerary item under /users/user123/trips/trip001/itinerary_items/item001.
     * @deny (get, list, create, update, delete) User with ID 'user456' cannot manage itinerary items of user 'user123'.
     *          Example: Request by user 'user456' to read an itinerary item under /users/user123/trips/trip001/itinerary_items/item001.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /local_businesses/{localBusinessId} collection.
     * @path /local_businesses/{localBusinessId}
     * @allow get, list: Any user can read the data.
     *          Example: Any user can read the details of a local business.
     * @deny create, update, delete: No user can create, update, or delete local business data through client-side rules.
     *          Example: Attempt to create a new local business will be denied.
     * @principle Public read access with no write access.
     */
    match /local_businesses/{localBusinessId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Security rules for the /app-stats/{statId} collection.
     * @path /app-stats/{statId}
     * @allow get, list: Any user can read the data.
     *          Example: Any user can read the app statistics.
     * @deny create, update, delete: No user can create, update, or delete app statistics through client-side rules.
     *          Example: Attempt to update the app statistics will be denied.
     * @principle Public read access with no write access.
     */
    match /app-stats/{statId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Security rules for the /supporters/{supporterId} collection.
     * @path /supporters/{supporterId}
     * @allow get, list: Any user can read the data.
     *          Example: Any user can read the supporter profiles.
     * @deny create, update, delete: No user can create, update, or delete supporter data through client-side rules.
     *          Example: Attempt to create a new supporter profile will be denied.
     * @principle Public read access with no write access.
     */
    match /supporters/{supporterId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Security rules for the /bookings/{bookingId} collection.
     * @path /bookings/{bookingId}
     * @allow get: Signed-in user can read a booking if they are the user or supporter involved.
     *          Example: User 'user123' can read a booking where userId is 'user123'.
     *          Example: Supporter 'supporter456' can read a booking where supporterId is 'supporter456'.
     * @allow list: Signed-in users to list (relaxed for hackathon demo).
     *          Example: A request to list bookings while authenticated
     * @allow create: Signed-in user can create a booking if their user ID matches the booking's userId.
     *          Example: User 'user123' can create a booking with userId set to 'user123'.
     * @deny update, delete: No direct updates or deletes from the client.
     *          Example: Attempt to update or delete a booking will be denied.
     * @principle Access is based on user or supporter involvement.  Relational integrity is enforced on create.
     */
    match /bookings/{bookingId} {
      allow get: if isSignedIn() &&
        (resource.data.userId == request.auth.uid ||
         resource.data.supporterId == request.auth.uid);

      allow list: if isSignedIn();

      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;

      allow update: if false;
      allow delete: if false;
    }
  }
}