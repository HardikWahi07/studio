/**
 * @fileoverview Firestore Security Rules for TripMind Application
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data (users, trips, expenses, itinerary items),
 * while allowing public read access to general data (local businesses, app stats, local supporters).  The rules
 * are designed to prevent unauthorized data access and modification, and to ensure data consistency.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data. Only the user can read/write their own data.
 * - /users/{userId}/trips/{tripId}: Stores trip data associated with a user. Only the user can manage their trips.
 * - /users/{userId}/trips/{tripId}/expenses/{expenseId}: Stores expense data associated with a trip and user.
 * - /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}: Stores itinerary items associated with a trip.
 * - /local_businesses/{localBusinessId}: Stores data for local businesses; publicly readable.
 * - /app-stats/{statId}: Stores global application statistics; publicly readable.
 * - /supporters/{supporterId}: Stores profiles of local supporters; publicly readable.
 * - /bookings/{bookingId}: Stores confirmed bookings; accessible to the involved user or supporter.
 *
 * Key Security Decisions:
 * - User data is strictly controlled by the user's ID in the path.
 * - Listing of all users is disallowed.
 * - Public collections (local_businesses, app-stats, supporters) are readable by anyone.
 * - Bookings can only be listed with a query that restricts results to the requesting user.
 *
 * Denormalization for Authorization:
 * - The 'Trip', 'Expense', and 'ItineraryItem' entities include a 'userId' field to simplify authorization checks and avoid costly 'get()' calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @returns {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource based on the provided userId.
     * @param {string} userId - The user ID to compare against the authenticated user's ID.
     * @returns {boolean} True if the user is the owner, false otherwise.
     * @example
     * // Check if the current user is the owner of a document.
     * allow read: if isOwner(resource.data.userId);
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of an existing resource based on the provided userId.
     * @param {string} userId - The user ID to compare against the authenticated user's ID.
     * @returns {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isSignedIn() && request.auth.uid == userId && resource.data.userId == userId;
    }
    
    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) - User with auth UID 'user_abc' can create their own profile at /users/user_abc.
     * @allow (get) - User with auth UID 'user_abc' can read their own profile at /users/user_abc.
     * @allow (update) - User with auth UID 'user_abc' can update their own profile at /users/user_abc.
     * @allow (delete) - User with auth UID 'user_abc' can delete their own profile at /users/user_abc.
     * @deny (create) - User with auth UID 'user_xyz' cannot create a profile at /users/user_abc.
     * @deny (get) - User with auth UID 'user_xyz' cannot read the profile at /users/user_abc.
     * @deny (update) - User with auth UID 'user_xyz' cannot update the profile at /users/user_abc.
     * @deny (delete) - User with auth UID 'user_xyz' cannot delete the profile at /users/user_abc.
     * @principle Enforces document ownership for all operations on user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing all users is not permitted.
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/trips/{tripId} collection.
     * @path /users/{userId}/trips/{tripId}
     * @allow (create) - User with auth UID 'user_abc' can create a trip under /users/user_abc/trips/{tripId}.
     * @allow (get) - User with auth UID 'user_abc' can read their trip at /users/user_abc/trips/{tripId}.
     * @allow (update) - User with auth UID 'user_abc' can update their trip at /users/user_abc/trips/{tripId}.
     * @allow (delete) - User with auth UID 'user_abc' can delete their trip at /users/user_abc/trips/{tripId}.
     * @deny (create) - User with auth UID 'user_xyz' cannot create a trip under /users/user_abc/trips/{tripId}.
     * @deny (get) - User with auth UID 'user_xyz' cannot read the trip at /users/user_abc/trips/{tripId}.
     * @deny (update) - User with auth UID 'user_xyz' cannot update the trip at /users/user_abc/trips/{tripId}.
     * @deny (delete) - User with auth UID 'user_xyz' cannot delete the trip at /users/user_abc/trips/{tripId}.
     * @principle Enforces document ownership for all operations on trips.
     */
    match /users/{userId}/trips/{tripId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/trips/{tripId}/expenses/{expenseId} collection.
     * @path /users/{userId}/trips/{tripId}/expenses/{expenseId}
     * @allow (create) - User with auth UID 'user_abc' can create an expense under their trip.
     * @allow (get) - User with auth UID 'user_abc' can read their expense.
     * @allow (update) - User with auth UID 'user_abc' can update their expense.
     * @allow (delete) - User with auth UID 'user_abc' can delete their expense.
     * @deny (create) - User with auth UID 'user_xyz' cannot create an expense under another user's trip.
     * @deny (get) - User with auth UID 'user_xyz' cannot read another user's expense.
     * @deny (update) - User with auth UID 'user_xyz' cannot update another user's expense.
     * @deny (delete) - User with auth UID 'user_xyz' cannot delete another user's expense.
     * @principle Enforces document ownership for all operations on expenses.
     */
    match /users/{userId}/trips/{tripId}/expenses/{expenseId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId} collection.
     * @path /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}
     * @allow (create) - User with auth UID 'user_abc' can create an itinerary item under their trip.
     * @allow (get) - User with auth UID 'user_abc' can read their itinerary item.
     * @allow (update) - User with auth UID 'user_abc' can update their itinerary item.
     * @allow (delete) - User with auth UID 'user_abc' can delete their itinerary item.
     * @deny (create) - User with auth UID 'user_xyz' cannot create an itinerary item under another user's trip.
     * @deny (get) - User with auth UID 'user_xyz' cannot read another user's itinerary item.
     * @deny (update) - User with auth UID 'user_xyz' cannot update another user's itinerary item.
     * @deny (delete) - User with auth UID 'user_xyz' cannot delete another user's itinerary item.
     * @principle Enforces document ownership for all operations on itinerary items.
     */
    match /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /local_businesses/{localBusinessId} collection.
     * @path /local_businesses/{localBusinessId}
     * @allow (get) - Any user, signed in or not, can read a local business.
     * @allow (list) - Any user, signed in or not, can list local businesses.
     * @deny (create) - No one can create a local business through client-side rules.
     * @deny (update) - No one can update a local business through client-side rules.
     * @deny (delete) - No one can delete a local business through client-side rules.
     * @principle Public read access, with restricted write access.
     */
    match /local_businesses/{localBusinessId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /app-stats/{statId} collection.
     * @path /app-stats/{statId}
     * @allow (get) - Any user, signed in or not, can read app stats.
     * @allow (list) - Any user, signed in or not, can list app stats.
     * @deny (create) - No one can create app stats through client-side rules.
     * @deny (update) - No one can update app stats through client-side rules.
     * @deny (delete) - No one can delete app stats through client-side rules.
     * @principle Public read access, with restricted write access.
     */
    match /app-stats/{statId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add role-based validation if only admins should be able to write app-stats.
      allow update: if false; // TODO: Add role-based validation if only admins should be able to write app-stats.
      allow delete: if false; // TODO: Add role-based validation if only admins should be able to write app-stats.
    }

    /**
     * @description Rules for the /supporters/{supporterId} collection.
     * @path /supporters/{supporterId}
     * @allow (get) - Any user, signed in or not, can read a local supporter's profile.
     * @allow (list) - Any user, signed in or not, can list local supporters.
     * @deny (create) - No one can create a local supporter through client-side rules.
     * @deny (update) - No one can update a local supporter through client-side rules.
     * @deny (delete) - No one can delete a local supporter through client-side rules.
     * @principle Public read access, with restricted write access.
     */
    match /supporters/{supporterId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add role-based validation if only admins should be able to create supporters.
      allow update: if false; // TODO: Add role-based validation if only admins should be able to update supporters.
      allow delete: if false; // TODO: Add role-based validation if only admins should be able to delete supporters.
    }

    /**
     * @description Rules for the /bookings/{bookingId} collection.
     * @path /bookings/{bookingId}
     * @allow (get) - User or supporter involved can read booking details.
     * @allow (list) - User can list bookings, filtered by their user ID.
     * @allow (create) - User can create a booking with their user ID.
     * @deny (update) - Only users can update their own bookings.
     * @deny (delete) - Only users can delete their own bookings.
     * @principle Enforces user-specific filtering for list operations and allows reads by involved parties.
     */
    match /bookings/{bookingId} {
        allow get: if isSignedIn() && (resource.data.userId == request.auth.uid || resource.data.supporterId == request.auth.uid);
        allow list: if isSignedIn() && request.query.where("userId", "==", request.auth.uid).size() > 0;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update: if isSignedIn() && request.auth.uid == resource.data.userId;
        allow delete: if isSignedIn() && request.auth.uid == resource.data.userId;
    }
  }
}