/**
 * @fileoverview Firestore Security Rules for TripMind Application
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data (users, trips, expenses, itinerary items),
 * while allowing public read access to shared resources (local businesses, app stats, local supporters).
 * Authorization decisions are based on the authenticated user's ID (`request.auth.uid`) and path-based ownership.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data.
 * - /users/{userId}/trips/{tripId}: Stores trip data associated with a user.
 * - /users/{userId}/trips/{tripId}/expenses/{expenseId}: Stores expense data associated with a trip and user.
 * - /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}: Stores itinerary items associated with a trip.
 * - /local_businesses/{localBusinessId}: Stores data for local businesses.
 * - /app-stats/{statId}: Stores global application statistics.
 * - /supporters/{supporterId}: Stores profiles of local supporters.
 * - /bookings/{bookingId}: Stores confirmed bookings.
 *
 * Key Security Decisions:
 * - User data (profiles, trips, expenses, itinerary items) is strictly controlled by the owning user.
 * - Public data (local businesses, app stats, local supporters) is readable by all users.
 * - List operations on bookings are restricted to the user's own bookings.
 * - The rules do not enforce the schema of the data being written, except for critical fields related to authorization.
 *
 * Denormalization for Authorization:
 * - Ownership is enforced via path-based rules (e.g., /users/{userId}/...). This eliminates the need for `get()` calls to verify ownership.
 * - The bookings collection uses a denormalized structure, storing both `userId` and `supporterId` on each booking document.
 * This allows for efficient security rules that grant access to either the user or the supporter involved in the booking.
 *
 * Structural Segregation:
 * - The application uses separate collections for private user data (/users/{userId}/...) and public data (local businesses, app stats, local supporters).
 * This segregation simplifies the security rules and improves performance for list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data. Only the user can read/write their own profile.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && isSignedIn();
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to trip data. Only the owning user can manage their trips.
     * @path /users/{userId}/trips/{tripId}
     */
    match /users/{userId}/trips/{tripId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && isSignedIn();
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to expense data. Only the owning user can manage expenses associated with their trips.
     * @path /users/{userId}/trips/{tripId}/expenses/{expenseId}
     */
    match /users/{userId}/trips/{tripId}/expenses/{expenseId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && isSignedIn();
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to itinerary item data. Only the owning user can manage itinerary items associated with their trips.
     * @path /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId}
     */
    match /users/{userId}/trips/{tripId}/itinerary_items/{itineraryItemId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && isSignedIn();
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows public read access to local business data. Write access is not defined.
     * @path /local_businesses/{localBusinessId}
     */
    match /local_businesses/{localBusinessId} {
      allow get: if true;
      allow list: if true;
    }

    /**
     * @description Allows public read access to application statistics. Write access is not defined.
     * @path /app-stats/{statId}
     */
    match /app-stats/{statId} {
      allow get: if true;
      allow list: if true;
    }

    /**
     * @description Allows public read access to local supporter profiles. Write access is not defined.
     * @path /supporters/{supporterId}
     */
    match /supporters/{supporterId} {
      allow get: if true;
      allow list: if true;
    }

    /**
     * @description Manages access to booking data. Users can only query bookings where their userId matches the authenticated user's ID.
     * Individual reads are allowed by either the user or the supporter involved in the booking.
     * @path /bookings/{bookingId}
     */
    match /bookings/{bookingId} {
      allow get: if resource.data.userId == request.auth.uid || resource.data.supporterId == request.auth.uid;
      allow list: if request.query.userId == request.auth.uid;
      allow create: if request.resource.data.userId == request.auth.uid && isSignedIn();
      allow update: if false;
      allow delete: if false;
    }
  }

  /**
   * @description Checks if the request is made by an authenticated user.
   * @returns {boolean} True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the authenticated user ID matches the provided user ID.
   * @param {string} userId The user ID to compare against.
   * @returns {boolean} True if the user is the owner, false otherwise.
   */
  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

    /**
   * @description Checks if the authenticated user ID matches the provided user ID and the resource exists.
   * @param {string} userId The user ID to compare against.
   * @returns {boolean} True if the user is the owner and the resource exists, false otherwise.
   */
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}